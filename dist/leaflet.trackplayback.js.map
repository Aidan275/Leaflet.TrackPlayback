{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///external {\"root\":\"L\",\"commonjs\":\"leaflet\",\"commonjs2\":\"leaflet\",\"amd\":\"leaflet\"}","webpack:///./src/leaflet.trackplayback/util.js","webpack:///./src/leaflet.trackplayback/track.js","webpack:///./src/leaflet.trackplayback/trackcontroller.js","webpack:///./src/leaflet.trackplayback/clock.js","webpack:///./src/leaflet.trackplayback/tracklayer.js","webpack:///./src/leaflet.trackplayback/draw.js","webpack:///./src/leaflet.trackplayback/trackplayback.js","webpack:///./src/leaflet.trackplayback/index.js"],"names":["root","factory","exports","module","require","define","amd","a","i","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","isArray","arr","Array","toString","Track","external_root_L_commonjs_leaflet_commonjs2_leaflet_amd_leaflet_default","Layer","extend","initialize","trackData","options","setOptions","this","forEach","item","isOrigin","_trackPoints","_timeTick","_update","addTrackPoint","trackPoint","len","length","_addTrackPoint","getTimes","times","push","time","getStartTrackPoint","getEndTrackPoint","getTrackPointByTime","getAllTrackPoints","_formatDistance","distance","toFixed","_getCalculateTrackPointByTime","endpoint","startPt","endPt","left","right","parseInt","t0","t1","p0","p1","point","lng","lat","distanceTo","v","radius","sinx","y","cosx","x","step","rstep","dir","Math","PI","asin","undefined","info","getTrackPointsBeforeTime","tpoints","_sortTrackPointsByTime","_updatetimeTick","j","tmp","TrackController","tracks","draw","_tracks","_tps","addTrack","_draw","_updateTime","getMinTime","_minTime","getMaxTime","_maxTime","getTrackPoints","track","Error","drawTracksByTime","clear","_drawnTracks","drawTrack","getCurrentPoints","prev","curr","next","stime","etime","Clock","speed","maxSpeed","trackController","_trackController","_endTime","_curTime","_speed","_maxSpeed","_intervalID","_lastFpsUpdateTime","start","Util","requestAnimFrame","_tick","stop","cancelAnimFrame","rePlaying","slowSpeed","quickSpeed","getSpeed","getCurTime","getStartTime","getEndTime","isPlaying","setCursor","fire","setSpeed","_caculatefpsTime","now","Date","isPause","stepTime","pow","TrackLayer","Renderer","padding","onAdd","map","_container","DomUtil","getPane","pane","appendChild","_ctx","getContext","onRemove","remove","getContainer","getBounds","_bounds","_map","_animatingZoom","b","container","size","getSize","Browser","retina","setPosition","min","width","height","style","scale","translate","Draw","trackPointOptions","isDraw","useCanvas","stroke","color","fill","fillColor","opacity","trackLineOptions","weight","targetOptions","useImg","imgUrl","showText","toolTipOptions","offset","direction","permanent","circleOptions","_showTrackPoint","_showTrackLine","on","_onmousemoveEvt","_onmouseclickEvt","_trackLayer","addTo","_trackLayerUpdate","_canvas","_bufferTracks","_trackPointFeatureGroup","featureGroup","img","Image","onload","_targetImg","onerror","src","update","trackpoints","_drawTrack","showTrackPoint","hideTrackPoint","showTrackLine","hideTrackLine","off","hasLayer","removeLayer","_tooltip","_circle","_shipRadius","_clearLayer","element","index","e","cursor","layerPoint","leni","tpoint","_getLayerPoint","_opentoolTip","trackpoint","latlng","latLng","tooltip","setLatLng","setContent","_getTooltipText","circle","setRadius","_drawTrackLine","targetPoint","_drawShipImage","_drawShipRadius","_drawShipCanvas","_drawTrackPointsCanvas","_drawTrackPointsSvg","tp0","save","beginPath","moveTo","tpi","lineTo","globalAlpha","strokeStyle","lineWidth","fillStyle","restore","latLngToLayerPoint","arc","cricleMarker","circleMarker","bindTooltip","addLayer","_drawtxt","text","font","textAlign","textBaseline","fillText","rotate","w","h","dh","closePath","drawImage","targetobj","content","ts","join","bounds","clearRect","clearLayers","TrackPlayBack","data","drawOptions","_initTracks","clock","clockOptions","dispose","trackplayback"],"mappings":"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","file":"leaflet.trackplayback.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"leaflet\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"leaflet\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"leaflet\")) : factory(root[\"L\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","export function isArray (arr) {\r\n  return Array.isArray ? Array.isArray(arr) : Object.prototype.toString.call(arr) === '[object Array]'\r\n}\r\n","import L from 'leaflet'\r\n\r\nimport {\r\n  isArray\r\n} from './util'\r\n\r\n/**\r\n * 轨迹类\r\n */\r\nexport const Track = L.Layer.extend({\r\n\r\n  initialize: function (trackData = [], options) {\r\n    L.setOptions(this, options)\r\n\r\n    trackData.forEach(item => {\r\n      // 添加 isOrigin 字段用来标识是否是原始采样点，与插值点区分开\r\n      item.isOrigin = true\r\n    })\r\n    this._trackPoints = trackData\r\n    this._timeTick = {}\r\n    this._update()\r\n  },\r\n\r\n  addTrackPoint: function (trackPoint) {\r\n    if (isArray(trackPoint)) {\r\n      for (let i = 0, len = trackPoint.length; i < len; i++) {\r\n        this.addTrackPoint(trackPoint[i])\r\n      }\r\n    }\r\n    this._addTrackPoint(trackPoint)\r\n  },\r\n\r\n  getTimes: function () {\r\n    let times = []\r\n    for (let i = 0, len = this._trackPoints.length; i < len; i++) {\r\n      times.push(this._trackPoints[i].time)\r\n    }\r\n    return times\r\n  },\r\n\r\n  getStartTrackPoint: function () {\r\n    return this._trackPoints[0]\r\n  },\r\n\r\n  getEndTrackPoint: function () {\r\n    return this._trackPoints[this._trackPoints.length - 1]\r\n  },\r\n\r\n  getTrackPointByTime: function (time) {\r\n    return this._trackPoints[this._timeTick[time]]\r\n  },\r\n\r\n  getAllTrackPoints: function () {\r\n    return this._trackPoints\r\n  },\r\n\r\n  _formatDistance: function (distance) {\r\n    return distance < 1000\r\n      ? `${distance.toFixed(2)} m`\r\n      : `${(distance / 1000).toFixed(2)} km`\r\n  },\r\n\r\n  _getCalculateTrackPointByTime: function (time) {\r\n    // First determine whether the last point is the original point\r\n    let endpoint = this.getTrackPointByTime(time)\r\n    let startPt = this.getStartTrackPoint()\r\n    let endPt = this.getEndTrackPoint()\r\n    let times = this.getTimes()\r\n    if (time < startPt.time || time > endPt.time) return\r\n    let left = 0\r\n    let right = times.length - 1\r\n    let n\r\n    // Handle only one point case\r\n    if (left === right) {\r\n      return endpoint\r\n    }\r\n    // [Binary search] method to find out the time interval of the current time\r\n    while (right - left !== 1) {\r\n      n = parseInt((left + right) / 2)\r\n      if (time > times[n]) left = n\r\n      else right = n\r\n    }\r\n\r\n    let t0 = times[left]\r\n    let t1 = times[right]\r\n    let t = time\r\n    let p0 = this.getTrackPointByTime(t0)\r\n    let p1 = this.getTrackPointByTime(t1)\r\n    startPt = L.point(p0.lng, p0.lat)\r\n    endPt = L.point(p1.lng, p1.lat)\r\n    let s = startPt.distanceTo(endPt)\r\n    // At the same point at different times\r\n    if (s <= 0) {\r\n      endpoint = p1\r\n      return endpoint\r\n    }\r\n    // Suppose the target moves in a straight line at a uniform speed between two points\r\n    // Find the velocity vector and calculate the time t where the target is\r\n    let v = s / (t1 - t0)\r\n    let r = (p1.radius - p0.radius) / (t1 - t0)\r\n    let sinx = (endPt.y - startPt.y) / s\r\n    let cosx = (endPt.x - startPt.x) / s\r\n    let step = v * (t - t0)\r\n    let rstep = r * (t - t0)\r\n    let x = startPt.x + step * cosx\r\n    let y = startPt.y + step * sinx\r\n    let radius = p0.radius + rstep\r\n    // Find the direction of movement of the target, 0-360 degrees\r\n    let dir = endPt.x >= startPt.x ? (Math.PI * 0.5 - Math.asin(sinx)) * 180 / Math.PI : (Math.PI * 1.5 + Math.asin(sinx)) * 180 / Math.PI\r\n\r\n    if (endpoint) {\r\n      if (endpoint.dir === undefined) {\r\n        endpoint.dir = dir\r\n      }\r\n      if (endpoint.radius === undefined) {\r\n        endpoint.radius = radius\r\n      }\r\n    } else {\r\n      endpoint = {\r\n        lng: x,\r\n        lat: y,\r\n        dir: dir,\r\n        isOrigin: false,\r\n        time: time,\r\n        radius: radius,\r\n        info: [\r\n          {\r\n            key: 'Accuracy:',\r\n            value: this._formatDistance(radius)\r\n          }\r\n        ]\r\n      }\r\n    }\r\n    return endpoint\r\n  },\r\n\r\n  // Get the trajectory before a certain point in time\r\n  getTrackPointsBeforeTime: function (time) {\r\n    let tpoints = []\r\n    for (let i = 0, len = this._trackPoints.length; i < len; i++) {\r\n      if (this._trackPoints[i].time < time) {\r\n        tpoints.push(this._trackPoints[i])\r\n      }\r\n    }\r\n    // Get the last point, linearly interpolated from time\r\n    let endPt = this._getCalculateTrackPointByTime(time)\r\n    if (endPt) {\r\n      tpoints.push(endPt)\r\n    }\r\n    return tpoints\r\n  },\r\n\r\n  _addTrackPoint: function (trackPoint) {\r\n    trackPoint.isOrigin = true\r\n    this._trackPoints.push(trackPoint)\r\n    this._update()\r\n  },\r\n\r\n  _update: function () {\r\n    this._sortTrackPointsByTime()\r\n    this._updatetimeTick()\r\n  },\r\n\r\n  // 轨迹点按时间排序 【冒泡排序】\r\n  _sortTrackPointsByTime: function () {\r\n    let len = this._trackPoints.length\r\n    for (let i = 0; i < len; i++) {\r\n      for (let j = 0; j < len - 1 - i; j++) {\r\n        if (this._trackPoints[j].time > this._trackPoints[j + 1].time) {\r\n          let tmp = this._trackPoints[j + 1]\r\n          this._trackPoints[j + 1] = this._trackPoints[j]\r\n          this._trackPoints[j] = tmp\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  // 为轨迹点建立时间索引，优化查找性能\r\n  _updatetimeTick: function () {\r\n    this._timeTick = {}\r\n    for (let i = 0, len = this._trackPoints.length; i < len; i++) {\r\n      this._timeTick[this._trackPoints[i].time] = i\r\n    }\r\n  }\r\n})\r\n\r\nexport const track = function (trackData, options) {\r\n  return new Track(trackData, options)\r\n}\r\n","import L from 'leaflet'\r\n\r\nimport {\r\n  isArray\r\n} from './util'\r\nimport {\r\n  Track\r\n} from './track'\r\n\r\n/**\r\n * 控制器类\r\n * 控制轨迹和绘制\r\n */\r\nexport const TrackController = L.Layer.extend({\r\n\r\n  initialize: function (tracks = [], draw, options) {\r\n    L.setOptions(this, options)\r\n\r\n    this._tracks = []\r\n    this._tps = []\r\n    this.addTrack(tracks)\r\n\r\n    this._draw = draw\r\n\r\n    this._updateTime()\r\n  },\r\n\r\n  getMinTime: function () {\r\n    return this._minTime\r\n  },\r\n\r\n  getMaxTime: function () {\r\n    return this._maxTime\r\n  },\r\n\r\n  getTrackPoints: function () {\r\n    return this._tps\r\n  },\r\n\r\n  addTrack: function (track) {\r\n    if (isArray(track)) {\r\n      for (let i = 0, len = track.length; i < len; i++) {\r\n        this.addTrack(track[i])\r\n      }\r\n    } else if (track instanceof Track) {\r\n      this._tracks.push(track)\r\n      this._updateTime()\r\n    } else {\r\n      throw new Error('tracks must be an instance of `Track` or an array of `Track` instance!')\r\n    }\r\n  },\r\n\r\n  drawTracksByTime: function (time) {\r\n    this._draw.clear()\r\n    this._drawnTracks = []\r\n    for (let i = 0, len = this._tracks.length; i < len; i++) {\r\n      let track = this._tracks[i]\r\n      this._tps = track.getTrackPointsBeforeTime(time)\r\n      if (this._tps && this._tps.length) this._draw.drawTrack(this._tps)\r\n    }\r\n  },\r\n\r\n  getCurrentPoints: function () {\r\n    return {\r\n      prev: this._tps[this._tps.length - 2],\r\n      curr: this._tps[this._tps.length - 1],\r\n      next: this._tracks[0].getAllTrackPoints()[this._tps.length]\r\n    }\r\n  },\r\n\r\n  _updateTime: function () {\r\n    this._minTime = this._tracks[0].getStartTrackPoint().time\r\n    this._maxTime = this._tracks[0].getEndTrackPoint().time\r\n    for (let i = 0, len = this._tracks.length; i < len; i++) {\r\n      let stime = this._tracks[i].getStartTrackPoint().time\r\n      let etime = this._tracks[i].getEndTrackPoint().time\r\n      if (stime < this._minTime) {\r\n        this._minTime = stime\r\n      }\r\n      if (etime > this._maxTime) {\r\n        this._maxTime = etime\r\n      }\r\n    }\r\n  }\r\n\r\n})\r\n\r\nexport const trackController = function (tracks, draw, options) {\r\n  return new TrackController(tracks, draw, options)\r\n}\r\n","import L from 'leaflet'\r\n/**\r\n * 时钟类，控制轨迹播放动画\r\n */\r\nexport const Clock = L.Layer.extend({\r\n\r\n  options: {\r\n    // 播放速度\r\n    // 计算方法 fpstime * Math.pow(2, this._speed - 1)\r\n    speed: 12,\r\n    // 最大播放速度\r\n    maxSpeed: 65\r\n  },\r\n\r\n  initialize: function (trackController, options) {\r\n    L.setOptions(this, options)\r\n\r\n    this._trackController = trackController\r\n    this._endTime = this._trackController.getMaxTime()\r\n    this._curTime = this._trackController.getMinTime()\r\n    this._speed = this.options.speed\r\n    this._maxSpeed = this.options.maxSpeed\r\n    this._intervalID = null\r\n    this._lastFpsUpdateTime = 0\r\n  },\r\n\r\n  start: function () {\r\n    if (this._intervalID) return\r\n    this._intervalID = L.Util.requestAnimFrame(this._tick, this)\r\n  },\r\n\r\n  stop: function () {\r\n    if (!this._intervalID) return\r\n    L.Util.cancelAnimFrame(this._intervalID)\r\n    this._intervalID = null\r\n    this._lastFpsUpdateTime = 0\r\n  },\r\n\r\n  rePlaying: function () {\r\n    this.stop()\r\n    this._curTime = this._trackController.getMinTime()\r\n    this.start()\r\n  },\r\n\r\n  slowSpeed: function () {\r\n    this._speed = this._speed <= 1 ? this._speed : this._speed - 1\r\n    if (this._intervalID) {\r\n      this.stop()\r\n      this.start()\r\n    }\r\n  },\r\n\r\n  quickSpeed: function () {\r\n    this._speed = this._speed >= this._maxSpeed ? this._speed : this._speed + 1\r\n    if (this._intervalID) {\r\n      this.stop()\r\n      this.start()\r\n    }\r\n  },\r\n\r\n  getSpeed: function () {\r\n    return this._speed\r\n  },\r\n\r\n  getCurTime: function () {\r\n    return this._curTime\r\n  },\r\n\r\n  getStartTime: function () {\r\n    return this._trackController.getMinTime()\r\n  },\r\n\r\n  getEndTime: function () {\r\n    return this._trackController.getMaxTime()\r\n  },\r\n\r\n  getTrackPoints: function () {\r\n    return this._trackController.getTrackPoints()\r\n  },\r\n\r\n  isPlaying: function () {\r\n    return !!this._intervalID\r\n  },\r\n\r\n  setCursor: function (time) {\r\n    this._curTime = time\r\n    this._trackController.drawTracksByTime(this._curTime)\r\n    const { prev, curr, next } = this._trackController.getCurrentPoints()\r\n    this.fire('tick', {\r\n      prev: prev,\r\n      curr: curr,\r\n      next: next,\r\n      time: this._curTime\r\n    })\r\n  },\r\n\r\n  setSpeed: function (speed) {\r\n    this._speed = speed\r\n    if (this._intervalID) {\r\n      this.stop()\r\n      this.start()\r\n    }\r\n  },\r\n\r\n  // 计算两帧时间间隔，单位：秒\r\n  _caculatefpsTime: function (now) {\r\n    let time\r\n    if (this._lastFpsUpdateTime === 0) {\r\n      time = 0\r\n    } else {\r\n      time = now - this._lastFpsUpdateTime\r\n    }\r\n    this._lastFpsUpdateTime = now\r\n    // 将毫秒转换成秒\r\n    time = time / 1000\r\n    return time\r\n  },\r\n\r\n  _tick: function () {\r\n    let now = +new Date()\r\n    let fpstime = this._caculatefpsTime(now)\r\n    let isPause = false\r\n    let stepTime = fpstime * Math.pow(2, this._speed - 1)\r\n    this._curTime += stepTime\r\n    if (this._curTime >= this._endTime) {\r\n      this._curTime = this._endTime\r\n      isPause = true\r\n    }\r\n    this._trackController.drawTracksByTime(this._curTime)\r\n    const { prev, curr, next } = this._trackController.getCurrentPoints()\r\n    this.fire('tick', {\r\n      prev: prev,\r\n      curr: curr,\r\n      next: next,\r\n      time: this._curTime\r\n    })\r\n    if (!isPause) this._intervalID = L.Util.requestAnimFrame(this._tick, this)\r\n  }\r\n})\r\n\r\nexport const clock = function (trackController, options) {\r\n  return new Clock(trackController, options)\r\n}\r\n","import L from 'leaflet'\r\n\r\n/**\r\n * 轨迹图层\r\n */\r\nexport const TrackLayer = L.Renderer.extend({\r\n\r\n  initialize: function (options) {\r\n    L.Renderer.prototype.initialize.call(this, options)\r\n    this.options.padding = 0.1\r\n  },\r\n\r\n  onAdd: function (map) {\r\n    this._container = L.DomUtil.create('canvas', 'leaflet-zoom-animated')\r\n\r\n    var pane = map.getPane(this.options.pane)\r\n    pane.appendChild(this._container)\r\n\r\n    this._ctx = this._container.getContext('2d')\r\n\r\n    this._update()\r\n  },\r\n\r\n  onRemove: function (map) {\r\n    L.DomUtil.remove(this._container)\r\n  },\r\n\r\n  getContainer: function () {\r\n    return this._container\r\n  },\r\n\r\n  getBounds: function () {\r\n    return this._bounds\r\n  },\r\n\r\n  _update: function () {\r\n    if (this._map._animatingZoom && this._bounds) {\r\n      return\r\n    }\r\n\r\n    L.Renderer.prototype._update.call(this)\r\n\r\n    var b = this._bounds\r\n\r\n    var container = this._container\r\n\r\n    var size = b.getSize()\r\n\r\n    var m = L.Browser.retina ? 2 : 1\r\n\r\n    L.DomUtil.setPosition(container, b.min)\r\n\r\n    // set canvas size (also clearing it); use double size on retina\r\n    container.width = m * size.x\r\n    container.height = m * size.y\r\n    container.style.width = size.x + 'px'\r\n    container.style.height = size.y + 'px'\r\n\r\n    if (L.Browser.retina) {\r\n      this._ctx.scale(2, 2)\r\n    }\r\n\r\n    // translate so we use the same path coordinates after canvas element moves\r\n    this._ctx.translate(-b.min.x, -b.min.y)\r\n\r\n    // Tell paths to redraw themselves\r\n    this.fire('update')\r\n  }\r\n})\r\n","import L from 'leaflet'\r\n\r\nimport {\r\n  TrackLayer\r\n} from './tracklayer'\r\n\r\n/**\r\n * Drawing class\r\n * Complete the drawing of trajectory lines, trajectory points and targets\r\n */\r\nexport const Draw = L.Layer.extend({\r\n\r\n  trackPointOptions: {\r\n    isDraw: true,\r\n    useCanvas: true,\r\n    stroke: true,\r\n    color: '#000',\r\n    fill: true,\r\n    fillColor: '#3388ff',\r\n    opacity: 1,\r\n    radius: 5\r\n  },\r\n  trackLineOptions: {\r\n    isDraw: true,\r\n    stroke: true,\r\n    color: '#3388ff',\r\n    weight: 2,\r\n    fill: false,\r\n    fillColor: '#000',\r\n    opacity: 1\r\n  },\r\n  targetOptions: {\r\n    useImg: false,\r\n    imgUrl: '../../static/images/ship.png',\r\n    showText: false,\r\n    width: 8,\r\n    height: 18,\r\n    color: '#00f', // stroke color\r\n    fillColor: '#9FD12D'\r\n  },\r\n  toolTipOptions: {\r\n    offset: [0, 0],\r\n    direction: 'top',\r\n    permanent: true\r\n  },\r\n  circleOptions: {\r\n    fillColor: '#00f'\r\n  },\r\n\r\n  initialize: function (map, options) {\r\n    L.extend(this.trackPointOptions, options.trackPointOptions)\r\n    L.extend(this.trackLineOptions, options.trackLineOptions)\r\n    L.extend(this.targetOptions, options.targetOptions)\r\n    L.extend(this.toolTipOptions, options.toolTipOptions)\r\n\r\n    this._showTrackPoint = this.trackPointOptions.isDraw\r\n    this._showTrackLine = this.trackLineOptions.isDraw\r\n\r\n    this._map = map\r\n    this._map.on('mousemove', this._onmousemoveEvt, this)\r\n    this._map.on('click', this._onmouseclickEvt, this)\r\n\r\n    this._trackLayer = new TrackLayer().addTo(map)\r\n    this._trackLayer.on('update', this._trackLayerUpdate, this)\r\n\r\n    this._canvas = this._trackLayer.getContainer()\r\n    this._ctx = this._canvas.getContext('2d')\r\n\r\n    this._bufferTracks = []\r\n\r\n    if (!this.trackPointOptions.useCanvas) {\r\n      this._trackPointFeatureGroup = L.featureGroup([]).addTo(map)\r\n    }\r\n\r\n    // If using a target, load the image first\r\n    if (this.targetOptions.useImg) {\r\n      const img = new Image()\r\n      img.onload = () => {\r\n        this._targetImg = img\r\n      }\r\n      img.onerror = () => {\r\n        throw new Error('img load error!')\r\n      }\r\n      img.src = this.targetOptions.imgUrl\r\n    }\r\n  },\r\n\r\n  update: function () {\r\n    this._trackLayerUpdate()\r\n  },\r\n\r\n  drawTrack: function (trackpoints) {\r\n    this._bufferTracks.push(trackpoints)\r\n    this._drawTrack(trackpoints)\r\n  },\r\n\r\n  showTrackPoint: function () {\r\n    this._showTrackPoint = true\r\n    this.update()\r\n  },\r\n\r\n  hideTrackPoint: function () {\r\n    this._showTrackPoint = false\r\n    this.update()\r\n  },\r\n\r\n  showTrackLine: function () {\r\n    this._showTrackLine = true\r\n    this.update()\r\n  },\r\n\r\n  hideTrackLine: function () {\r\n    this._showTrackLine = false\r\n    this.update()\r\n  },\r\n\r\n  remove: function () {\r\n    this._bufferTracks = []\r\n    this._trackLayer.off('update', this._trackLayerUpdate, this)\r\n    this._map.off('mousemove', this._onmousemoveEvt, this)\r\n    this._map.off('click', this._onmouseclickEvt, this)\r\n    if (this._map.hasLayer(this._trackLayer)) {\r\n      this._map.removeLayer(this._trackLayer)\r\n    }\r\n    if (this._map.hasLayer(this._trackPointFeatureGroup)) {\r\n      this._map.removeLayer(this._trackPointFeatureGroup)\r\n    }\r\n    if (this._map.hasLayer(this._tooltip)) {\r\n      this._map.removeLayer(this._tooltip)\r\n    }\r\n    if (this._map.hasLayer(this._circle)) {\r\n      this._map.removeLayer(this._circle)\r\n    }\r\n    if (this._map.hasLayer(this._shipRadius)) {\r\n      this._map.removeLayer(this._shipRadius)\r\n    }\r\n  },\r\n\r\n  clear: function () {\r\n    this._clearLayer()\r\n    this._bufferTracks = []\r\n  },\r\n\r\n  _trackLayerUpdate: function () {\r\n    if (this._bufferTracks.length) {\r\n      this._clearLayer()\r\n      this._bufferTracks.forEach(function (element, index) {\r\n        this._drawTrack(element)\r\n      }.bind(this))\r\n    }\r\n  },\r\n\r\n  _onmousemoveEvt: function (e) {\r\n    if (this._map.hasLayer(this._tooltip)) {\r\n      this._map.removeLayer(this._tooltip)\r\n    }\r\n    if (this._map.hasLayer(this._circle)) {\r\n      this._map.removeLayer(this._circle)\r\n    }\r\n    if (!this._showTrackPoint) {\r\n      this._canvas.style.cursor = 'grab'\r\n      return\r\n    }\r\n    let point = e.layerPoint\r\n    if (this._bufferTracks.length) {\r\n      for (let i = 0, leni = this._bufferTracks.length; i < leni; i++) {\r\n        for (let j = 0, len = this._bufferTracks[i].length; j < len; j++) {\r\n          let tpoint = this._getLayerPoint(this._bufferTracks[i][j])\r\n          if (point.distanceTo(tpoint) <= this.trackPointOptions.radius) {\r\n            this._canvas.style.cursor = 'pointer'\r\n            this._opentoolTip(this._bufferTracks[i][j])\r\n            return\r\n          }\r\n        }\r\n      }\r\n    }\r\n    this._canvas.style.cursor = 'grab'\r\n  },\r\n\r\n  _onmouseclickEvt: function (e) {\r\n    if (this._map.hasLayer(this._tooltip)) {\r\n      this._map.removeLayer(this._tooltip)\r\n    }\r\n    if (this._map.hasLayer(this._circle)) {\r\n      this._map.removeLayer(this._circle)\r\n    }\r\n    let point = e.layerPoint\r\n    if (this._bufferTracks.length) {\r\n      for (let i = 0, leni = this._bufferTracks.length; i < leni; i++) {\r\n        for (let j = 0, len = this._bufferTracks[i].length; j < len; j++) {\r\n          let tpoint = this._getLayerPoint(this._bufferTracks[i][j])\r\n          if (point.distanceTo(tpoint) <= this.trackPointOptions.radius) {\r\n            this.fire('click', this._bufferTracks[i][j])\r\n            this._opentoolTip(this._bufferTracks[i][j])\r\n            return\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  _opentoolTip: function (trackpoint) {\r\n    let latlng = L.latLng(trackpoint.lat, trackpoint.lng)\r\n\r\n    if (trackpoint.info) {\r\n      let tooltip = this._tooltip = L.tooltip(this.toolTipOptions)\r\n      tooltip.setLatLng(latlng)\r\n      tooltip.addTo(this._map)\r\n      tooltip.setContent(this._getTooltipText(trackpoint))\r\n    }\r\n\r\n    if (trackpoint.radius) {\r\n      let circle = this._circle = L.circle(this.circleOptions)\r\n      circle.setLatLng(latlng)\r\n      circle.setRadius(trackpoint.radius)\r\n      circle.addTo(this._map)\r\n    }\r\n  },\r\n\r\n  _drawTrack: function (trackpoints) {\r\n    // Trajectory line\r\n    if (this._showTrackLine) {\r\n      this._drawTrackLine(trackpoints)\r\n    }\r\n    // Drawing ship\r\n    let targetPoint = trackpoints[trackpoints.length - 1]\r\n    if (this.targetOptions.useImg && this._targetImg) {\r\n      this._drawShipImage(targetPoint)\r\n    } else {\r\n      this._drawShipRadius(targetPoint)\r\n      this._drawShipCanvas(targetPoint)\r\n    }\r\n    // Trajectory points drawn\r\n    if (this._showTrackPoint) {\r\n      if (this.trackPointOptions.useCanvas) {\r\n        this._drawTrackPointsCanvas(trackpoints)\r\n      } else {\r\n        this._drawTrackPointsSvg(trackpoints)\r\n      }\r\n    }\r\n  },\r\n\r\n  _drawTrackLine: function (trackpoints) {\r\n    let options = this.trackLineOptions\r\n    let tp0 = this._getLayerPoint(trackpoints[0])\r\n    this._ctx.save()\r\n    this._ctx.beginPath()\r\n    // Trajectory line\r\n    this._ctx.moveTo(tp0.x, tp0.y)\r\n    for (let i = 1, len = trackpoints.length; i < len; i++) {\r\n      let tpi = this._getLayerPoint(trackpoints[i])\r\n      this._ctx.lineTo(tpi.x, tpi.y)\r\n    }\r\n    this._ctx.globalAlpha = options.opacity\r\n    if (options.stroke) {\r\n      this._ctx.strokeStyle = options.color\r\n      this._ctx.lineWidth = options.weight\r\n      this._ctx.stroke()\r\n    }\r\n    if (options.fill) {\r\n      this._ctx.fillStyle = options.fillColor\r\n      this._ctx.fill()\r\n    }\r\n    this._ctx.restore()\r\n  },\r\n\r\n  _drawTrackPointsCanvas: function (trackpoints) {\r\n    let options = this.trackPointOptions\r\n    this._ctx.save()\r\n    for (let i = 0, len = trackpoints.length; i < len; i++) {\r\n      if (trackpoints[i].isOrigin) {\r\n        let latLng = L.latLng(trackpoints[i].lat, trackpoints[i].lng)\r\n        let radius = options.radius\r\n        let point = this._map.latLngToLayerPoint(latLng)\r\n        this._ctx.beginPath()\r\n        this._ctx.arc(point.x, point.y, radius, 0, Math.PI * 2, false)\r\n        this._ctx.globalAlpha = options.opacity\r\n        if (options.stroke) {\r\n          this._ctx.strokeStyle = options.color\r\n          this._ctx.stroke()\r\n        }\r\n        if (options.fill) {\r\n          this._ctx.fillStyle = options.fillColor\r\n          this._ctx.fill()\r\n        }\r\n      }\r\n    }\r\n    this._ctx.restore()\r\n  },\r\n\r\n  _drawTrackPointsSvg: function (trackpoints) {\r\n    for (let i = 0, len = trackpoints.length; i < len; i++) {\r\n      if (trackpoints[i].isOrigin) {\r\n        let latLng = L.latLng(trackpoints[i].lat, trackpoints[i].lng)\r\n        let cricleMarker = L.circleMarker(latLng, this.trackPointOptions)\r\n        cricleMarker.bindTooltip(this._getTooltipText(trackpoints[i]), this.toolTipOptions)\r\n        this._trackPointFeatureGroup.addLayer(cricleMarker)\r\n      }\r\n    }\r\n  },\r\n\r\n  _drawtxt: function (text, trackpoint) {\r\n    let point = this._getLayerPoint(trackpoint)\r\n    this._ctx.save()\r\n    this._ctx.font = '12px Verdana'\r\n    this._ctx.fillStyle = '#000'\r\n    this._ctx.textAlign = 'center'\r\n    this._ctx.textBaseline = 'bottom'\r\n    this._ctx.fillText(text, point.x, point.y - 12, 200)\r\n    this._ctx.restore()\r\n  },\r\n\r\n  _drawShipCanvas: function (trackpoint) {\r\n    let point = this._getLayerPoint(trackpoint)\r\n    let rotate = trackpoint.dir || 0\r\n    let w = this.targetOptions.width\r\n    let h = this.targetOptions.height\r\n    let dh = h / 3\r\n\r\n    this._ctx.save()\r\n    this._ctx.fillStyle = this.targetOptions.fillColor\r\n    this._ctx.strokeStyle = this.targetOptions.color\r\n    this._ctx.translate(point.x, point.y)\r\n    this._ctx.rotate((Math.PI / 180) * rotate)\r\n    this._ctx.beginPath()\r\n    this._ctx.moveTo(0, 0 - h / 2)\r\n    this._ctx.lineTo(0 - w / 2, 0 - h / 2 + dh)\r\n    this._ctx.lineTo(0 - w / 2, 0 + h / 2)\r\n    this._ctx.lineTo(0 + w / 2, 0 + h / 2)\r\n    this._ctx.lineTo(0 + w / 2, 0 - h / 2 + dh)\r\n    this._ctx.closePath()\r\n    this._ctx.fill()\r\n    this._ctx.stroke()\r\n\r\n    this._ctx.restore()\r\n  },\r\n\r\n  // Draw estimated accuracy radius of current location\r\n  _drawShipRadius: function (trackpoint) {\r\n    if (this._map.hasLayer(this._shipRadius)) {\r\n      this._map.removeLayer(this._shipRadius)\r\n    }\r\n\r\n    let latlng = L.latLng(trackpoint.lat, trackpoint.lng)\r\n    let circle = this._shipRadius = L.circle(this.circleOptions)\r\n    circle.setLatLng(latlng)\r\n    circle.setRadius(trackpoint.radius)\r\n    circle.addTo(this._map)\r\n  },\r\n\r\n  _drawShipImage: function (trackpoint) {\r\n    let point = this._getLayerPoint(trackpoint)\r\n    let dir = trackpoint.dir || 0\r\n    let width = this.targetOptions.width\r\n    let height = this.targetOptions.height\r\n    let offset = {\r\n      x: width / 2,\r\n      y: height / 2\r\n    }\r\n    this._ctx.save()\r\n    this._ctx.translate(point.x, point.y)\r\n    this._ctx.rotate((Math.PI / 180) * dir)\r\n    this._ctx.drawImage(this._targetImg, 0 - offset.x, 0 - offset.y, width, height)\r\n    this._ctx.restore()\r\n  },\r\n\r\n  _getTooltipText: function (targetobj) {\r\n    let content = []\r\n    content.push('<table>')\r\n    if (targetobj.ts) {\r\n      content.push('<tr>')\r\n      content.push(targetobj.ts)\r\n      content.push('</tr>')\r\n    }\r\n    if (targetobj.info && targetobj.info.length) {\r\n      for (let i = 0, len = targetobj.info.length; i < len; i++) {\r\n        content.push('<tr>')\r\n        content.push('<td>' + targetobj.info[i].key + '</td>')\r\n        content.push('<td>' + targetobj.info[i].value + '</td>')\r\n        content.push('</tr>')\r\n      }\r\n    }\r\n    content.push('</table>')\r\n    content = content.join('')\r\n    return content\r\n  },\r\n\r\n  _clearLayer: function () {\r\n    let bounds = this._trackLayer.getBounds()\r\n    if (bounds) {\r\n      let size = bounds.getSize()\r\n      this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y)\r\n    } else {\r\n      this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height)\r\n    }\r\n    if (this._map.hasLayer(this._trackPointFeatureGroup)) {\r\n      this._trackPointFeatureGroup.clearLayers()\r\n    }\r\n  },\r\n\r\n  _getLayerPoint: function (trackpoint) {\r\n    return this._map.latLngToLayerPoint(L.latLng(trackpoint.lat, trackpoint.lng))\r\n  }\r\n})\r\n\r\nexport const draw = function (map, options) {\r\n  return new Draw(map, options)\r\n}\r\n","import L from 'leaflet'\r\nimport {\r\n  Track\r\n} from './track'\r\nimport {\r\n  TrackController\r\n} from './trackcontroller'\r\nimport {\r\n  Clock\r\n} from './clock'\r\nimport {\r\n  Draw\r\n} from './draw'\r\nimport * as Util from './util'\r\n\r\n/**\r\n * single track data\r\n * [{lat: 30, lng: 116, time: 1502529980, heading: 300, info:[]},{},....]\r\n *\r\n * mutiple track data\r\n * [single track data, single track data, single track data]\r\n */\r\nexport const TrackPlayBack = L.Layer.extend({\r\n\r\n  initialize: function (data, map, options = {}) {\r\n    let drawOptions = {\r\n      trackPointOptions: options.trackPointOptions,\r\n      trackLineOptions: options.trackLineOptions,\r\n      targetOptions: options.targetOptions,\r\n      toolTipOptions: options.toolTipOptions\r\n    }\r\n    this.tracks = this._initTracks(data)\r\n    this.draw = new Draw(map, drawOptions)\r\n    this.draw.on('click', e => this.fire('click', e), this)\r\n    this.trackController = new TrackController(this.tracks, this.draw)\r\n    this.clock = new Clock(this.trackController, options.clockOptions)\r\n    this.clock.on('tick', this._tick, this)\r\n  },\r\n  start: function () {\r\n    this.clock.start()\r\n    return this\r\n  },\r\n  stop: function () {\r\n    this.clock.stop()\r\n    return this\r\n  },\r\n  rePlaying: function () {\r\n    this.clock.rePlaying()\r\n    return this\r\n  },\r\n  slowSpeed: function () {\r\n    this.clock.slowSpeed()\r\n    return this\r\n  },\r\n  quickSpeed: function () {\r\n    this.clock.quickSpeed()\r\n    return this\r\n  },\r\n  getSpeed: function () {\r\n    return this.clock.getSpeed()\r\n  },\r\n  getCurTime: function () {\r\n    return this.clock.getCurTime()\r\n  },\r\n  getStartTime: function () {\r\n    return this.clock.getStartTime()\r\n  },\r\n  getEndTime: function () {\r\n    return this.clock.getEndTime()\r\n  },\r\n  getTrackPoints: function () {\r\n    return this.clock.getTrackPoints()\r\n  },\r\n  isPlaying: function () {\r\n    return this.clock.isPlaying()\r\n  },\r\n  setCursor: function (time) {\r\n    this.clock.setCursor(time)\r\n    return this\r\n  },\r\n  setSpeed: function (speed) {\r\n    this.clock.setSpeed(speed)\r\n    return this\r\n  },\r\n  showTrackPoint: function () {\r\n    this.draw.showTrackPoint()\r\n    return this\r\n  },\r\n  hideTrackPoint: function () {\r\n    this.draw.hideTrackPoint()\r\n    return this\r\n  },\r\n  showTrackLine: function () {\r\n    this.draw.showTrackLine()\r\n    return this\r\n  },\r\n  hideTrackLine: function () {\r\n    this.draw.hideTrackLine()\r\n    return this\r\n  },\r\n  dispose: function () {\r\n    this.clock.off('tick', this._tick)\r\n    this.clock.stop()\r\n    this.draw.remove()\r\n    this.tracks = null\r\n    this.draw = null\r\n    this.trackController = null\r\n    this.clock = null\r\n  },\r\n  _tick: function (e) {\r\n    this.fire('tick', e)\r\n  },\r\n  _initTracks: function (data) {\r\n    let tracks = []\r\n    if (Util.isArray(data)) {\r\n      if (Util.isArray(data[0])) {\r\n        // 多条轨迹\r\n        for (let i = 0, len = data.length; i < len; i++) {\r\n          tracks.push(new Track(data[i]))\r\n        }\r\n      } else {\r\n        // 单条轨迹\r\n        tracks.push(new Track(data))\r\n      }\r\n    }\r\n    return tracks\r\n  }\r\n})\r\n\r\nexport const trackplayback = function (data, map, options) {\r\n  return new TrackPlayBack(data, map, options)\r\n}\r\n","import L from 'leaflet'\r\n\r\nimport {\r\n  TrackPlayBack,\r\n  trackplayback\r\n} from './trackplayback'\r\n\r\nL.TrackPlayBack = TrackPlayBack\r\nL.trackplayback = trackplayback\r\n"],"sourceRoot":""}